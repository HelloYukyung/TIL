서론
====
<h2>PS(problem solving)</h2> 
주어진 문제에 대해 제한된 시간과 메모리 내에서 문제를 해결하는 행위<br/>

PS의 단계에는 크게 구현(if,for,,), 자료구조(스택,큐,덱), 알고리즘, 문제(DFS,이진탐색)이 있음 

나는 지금 구현단계임. 그치만 문제 단계에서 입력의 크기가 커지면 시간복잡도와 공간복잡도를 고려하게 될 것임.

시간복잡도 때문에 결과값이 맞는데도 시간초과에러(TLE.Time Limit Exceeded)가 발생할 수 있음.

물론 지금 푸는 문제단계도 시간복잡도와 공간복잡도에 제한을 두지만 문제가 너무 린하기 때문에 신경도 안쓰고 잘만 풀어온것 ^^,,

미래의 나에게 고생한다는 말을 전하며,,,
이제 시간복잡도와 공간복잡도에 대해서 알아보자!

복잡도 
====

점근적 복잡도 <br/>
입력크기가 충분히 클 때, 시간복잡도와 공간복잡도를 분석하는 것을 말한다.

O(빅오), Ω(오메가), Θ(세타) 등이 있고, 빅오와 세타표기가 많이 사용된다.


시간복잡도
====
당연하게 생각하!면 실행시간이 적게 걸리는 알고리즘이 좋은 알고리즘즉, 시간복잡도는 알고리즘의 성능을 의미한다.  <br/>
알고리즘을 수행하기 위해 프로세스가 수행해야하는 연산을 수치화 한 것 (명령어의 실행횟수 N만을 고려) <br/>


보통 Big O()표기법을 많이 사용(Big O(복잡도)). <br/>

Big O표기법의 종류는 다음과 같다. 
 <br/> 


1. O(1) – 상수 시간 : 

제일 실행시간이 빠름. <br/>
문제를 해결하는데 오직 한 단계만 처리함. <br/>
(n이 1이든 100이든지 한 단계만 처리하면 결과가 나옴)
2,나 3과 같이 다른 상수시간도 존재하나 점근적으로 봤을 때 1에 가까우므로 1이라고 지정

2. O(log n) – 로그 시간 : 

문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듬(set 자료구조- 이진탐색트리). <br/>
(set자료구조  2가지 특징
(1). 집합을 허용하지 않음 
(2). 순서가 없음. 
)~~

3. O(n) – 직선적 시간 : 

복잡도와 입력값 n이 1:1 관계를 가짐(y=x,list).
(for문 하나로 해결)


4. O(n log n) : 

문제를 해결하기 위한 단계의 수가 N*(log2N) 번만큼의 수행시간을 가진다. <br/>
수가 2배로 늘 때, 연산횟수가 2배 조금 넘게 증가한다.
(선형로그형) <br/>
(퀵 정렬-분할정복, 기준값을 정해서 작은값은 왼쪽 큰값은 오른쪽으로 옮기는 방식으로 정렬하고 이를 반복 (평균복잡도는 nlogn이지만 최악의 경우엔 n2) )

5. O(n^2) – 2차 시간 : 

문제를 해결하기 위한 단계의 수는 입력값 n의 제곱(이중 for 문)

6. O(C^n) – 지수 시간 :

 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱( 2^n,, )




공간복잡도 
====
공간복잡도는 알고리즘이 실행될때 사용하는 메모리의 양

예시로 내가 리팩토링한 백준 2562 문제를 가지고 와봤다 .

```python
# 시간 복잡도 : O(n^2)

import sys 
input= sys.stdin.readline

num_list = []
count =1
max_n = 0
for i in range(1, 10):
    num_list.append(int(input()))
    
    for num in num_list:
        if num > max_n:
            max_n = num 
            count = i

print(max_n)
print(count)
```

위 코드는 리팩토링 하기 전 코드 

코드를 자세히 보면,
나는 for문으로 가져온 input값을 가져오고 싶었는데 num_list로 이전값들까지 계속 저장돼서 가져와지는 것을 볼 수 있음. <br/>
num_list 공간 복잡도는 O(n)  <br/>
input값이 9 개라 망정(?)이지 input값이 좀더 많았으면,,,:) <br/>

리팩토링하면서 num_list를 없애고 받아온 수를 바로 넘겨줌으로써 4*9 =36byte의 낭비를 4byte로 줄여줌(정수의 크기는4byte) <br/>

```python 
##refactoring
# 시간 복잡도 :O(n)
import sys 
input= sys.stdin.readline


count = 1
max_n = 0


for i in range(1,10):
    num=int(input())
    if num > max_n:
        max_n = num
        count = i

print(max_n)
print(count)

```
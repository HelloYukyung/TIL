# 함수 스코프 & 블록 스코프

## 스코프 & 컨텍스트

스코프  
함수가 실행될 때, 함수 내에서 변수에 대한 접근이 어떻게 되는지를 나타내는 용어이다.  
함수가 선언되면 무조건 스코프가 선언된다.

컨텍스트  
 this의 키워드 값이 무엇인지를 나타내는 용어이다.  
현재 실행 컨텍스트 내에서 어떤 객체를 참조하고 있는지를 의미하며, 객체를 기반으로 한 용어이다.

## 함수 스코프

자바스크립트는 기본적으로 함수 스코프를 따르는 언어이다.  
함수 스코프를 따른다는 의미는, 새로운 함수가 생성될 때마다 새로운 스코프가 발생된다는 뜻이다.

```js
if (5 > 4) {
  var secret = "12345";
}

console.log(secret);
// '12345'
```

위 코드에서는 함수가 선언되어 있지 않기 때문에 새로운 환경, 새로운 스코프가 형성되지 않는다.  
스코프가 형성되지 않으므로 동일한 실행 컨텍스트 내에 존재한다(글로벌 실행 컨텍스트).  
 따라서, 어디에서나 secret 변수에 대한 접근이 가능하고,'12345'를 출력하게 된다.

```
function a() {
  var secret = '12345';
}
secret; // ReferenceError

```

반면, 위 코드에서는 함수를 만들고 그 안에 변수를 저장해주었다.  
이 경우에는 함수 생성과 동시에 a 함수에 대한 새로운 실행 컨텍스트가 생성되고, 이 실행 컨텍스트 내부에 존재하는 변수 환경에 secret 변수가 저장된다.  
따라서 함수 외부에서 secret에 접근하려고 할 경우 스코프가 다르기 때문에 해당 변수에 접근이 불가능하다.  
(함수 외부는 global scope이지만, 함수 내부는 a 함수의 scope이므로, 부모 스코프는 자식 스코프에게 간섭할 수가 없기 때문에 접근이 불가능하다.)

## 블록 스코프

함수 스코프가 함수 생성시마다 새로운 스코프가 생성되는 것을 의미한다면, 블록 스코프는 말 그대로 블록 {}이 생성될 때마다 새로운 스코프가 형성되는 것을 의미한다.  
원래 자바스크립트는 함수 스코프를 따르지만, let과 const 키워드의 등장으로 블록 스코프를 형성하는 것도 가능해졌다.

```js
function loop() {
  for (var i = 0; i < 5; i++) {
    console.log(i);
  }
  console.log("final", i);
}
loop();
/*
0
1
2
3
4
final 5
*/
```

위 코드에서는 for 문 안에서 변수 i를 var 키워드로 초기화 해줬다.  
이 경우, 블록 스코프가 아닌 함수 스코프를 따르게 되는데, for 문 안쪽과 바깥 쪽에서 모두 변수 i에 접근해서 console.log를 하고 있다.  
여기서 i는 loop이라는 함수 스코프 안에 둘 모두 존재하기 때문에 문제 없이 for문 안이든 밖이든 문제 없이 i에 접근해서 값을 출력한다.

```js
function loop() {
  for (let i = 0; i < 5; i++) {
    console.log(i);
  }
  console.log("final", i);
}
loop();
/*
ReferenceError: i is not defined
*/
```

반면 for문 내에서 변수 i를 let으로 선언했을 경우, let으로 선언하는 순간, 변수 i는 for문 내에만 종속되며, 스코프가 다르므로 for문 외부에서는 i에 접근할 수가 없다.
